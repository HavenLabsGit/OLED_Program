Disassembly Listing for OLED
Generated From:
/home/rcjk/Nextcloud/Programming/OLED.X/dist/default/debug/OLED.X.debug.elf
Oct 2, 2022 1:49:41 PM

---  /tmp/xcXciiKeM.s  ----------------------------------------------------------------------------------
0572  00FE     MOVWF btemp
0573  0012     MOVIW FSR0++
0574  001E     MOVWI FSR1++
0575  0BFE     DECFSZ btemp, F
0576  2D73     GOTO 0x573
0577  3400     RETLW 0x0
07EA  30B4     MOVLW 0xB4
07EB  0084     MOVWF FSR0
07EC  3085     MOVLW 0x85
07ED  0085     MOVWF FSR0H
07EE  303A     MOVLW 0x3A
07EF  0086     MOVWF FSR1
07F0  3000     MOVLW 0x0
07F1  0087     MOVWF FSR1H
07F2  3012     MOVLW 0x12
07F3  3185     MOVLP 0x5
07F6  01CC     CLRF __pbssBANK0
07F7  01CD     CLRF 0x4D
07F8  01CE     CLRF 0x4E
07F9  01CF     CLRF y_pos
07FA  01D0     CLRF x_pos
07FB  01D1     CLRF 0x51
07FC  01D2     CLRF rx_data
07FD  0140     MOVLB 0x0
07FE  3186     MOVLP 0x6
---  /opt/microchip/xc8/v2.35/pic/sources/c99/common/Umul8.c  -------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
05C6  00F3     MOVWF size_array
5:             {
6:             	unsigned char product = 0;
05C7  01F2     CLRF product
7:             
8:             #if defined(__OPTIMIZE_SPEED__)
9:             
10:            	if(multiplier & 0x01)
11:            		product = (product + multiplicand) & 0xff;
12:            	multiplicand <<= 1;
13:            
14:            	if(multiplier & 0x02)
15:            		product = (product + multiplicand) & 0xff;
16:            	multiplicand <<= 1;
17:            
18:            	if(multiplier & 0x04)
19:            		product = (product + multiplicand) & 0xff;
20:            	multiplicand <<= 1;
21:            
22:            	if(multiplier & 0x08)
23:            		product = (product + multiplicand) & 0xff;
24:            	multiplicand <<= 1;
25:            
26:            	if(multiplier & 0x10)
27:            		product = (product + multiplicand) & 0xff;
28:            	multiplicand <<= 1;
29:            
30:            	if(multiplier & 0x20)
31:            		product = (product + multiplicand) & 0xff;
32:            	multiplicand <<= 1;
33:            
34:            	if(multiplier & 0x40)
35:            		product = (product + multiplicand) & 0xff;
36:            	multiplicand <<= 1;
37:            
38:            	if(multiplier & 0x80)
39:            		product = (product + multiplicand) & 0xff;
40:            
41:            #else
42:            	do {
43:            		if(multiplier & 1)
05C8  1C73     BTFSS size_array, 0x0
05C9  2DCB     GOTO 0x5CB
05CA  2DCC     GOTO 0x5CC
05CB  2DD0     GOTO 0x5D0
44:            			product += multiplicand;
05CC  0870     MOVF __pcstackCOMMON, W
05CD  00F1     MOVWF array
05CE  0871     MOVF array, W
05CF  07F2     ADDWF product, F
45:            		multiplicand <<= 1;
05D0  1003     BCF STATUS, 0x0
05D1  0DF0     RLF __pcstackCOMMON, F
46:            		multiplier >>= 1;
05D2  1003     BCF STATUS, 0x0
05D3  0CF3     RRF size_array, F
47:            	} while(multiplier != 0);
05D4  0873     MOVF size_array, W
05D5  1D03     BTFSS STATUS, 0x2
05D6  2DD8     GOTO 0x5D8
05D7  2DD9     GOTO 0x5D9
05D8  2DC8     GOTO 0x5C8
48:            
49:            #endif
50:            	return product;
05D9  0872     MOVF product, W
51:            }
05DA  0008     RETURN
---  /home/rcjk/Nextcloud/Programming/PIC16F18877/libs/i2c_drivers.c  -----------------------------------
1:             
2:             #include <stdint.h>
3:             #include "i2c_drivers.h"
4:             #include "pic16f18877.h"
5:             
6:             
7:             /***************************************************************************
8:              ============================ Public Functions =============================
9:              ***************************************************************************/
10:            
11:            /* Name: I2C_INIT
12:             * Parameter: void
13:             * Return: nothing
14:             * Description: Function initializes the ucontroller for I2C communication
15:             */
16:            
17:            
18:            void I2C_Init(void){
19:                
20:                RC3_DIGITAL;
05DB  017E     MOVLB 0x3E
05DC  11CE     BCF ANSELC, 0x3
21:                RC4_DIGITAL;
05DD  124E     BCF ANSELC, 0x4
22:                SSP_SLEW_RATE = 0;
05DE  0143     MOVLB 0x3
05DF  138F     BCF SSP1STAT, 0x7
23:                SSP_SMBUS_EN = DISABLE;
05E0  130F     BCF SSP1STAT, 0x6
24:                SSP_CLOCK = CLOCK_400KHZ; /* Sets I2C clock to 400kHz */
05E1  3009     MOVLW 0x9
05E2  008D     MOVWF SSP1ADD
25:                SSP_ENABLE = ENABLE; /* Enables the SDA and SCL pins as source */
05E3  1690     BSF SSP1CON1, 0x5
26:                SSP_MODE = MASTER_MODE; /* I2C Master Mode clock = Fosc / (4 * (SSP1ADD +1)) */
05E4  0810     MOVF SSP1CON1, W
05E5  39F0     ANDLW 0xF0
05E6  3808     IORLW 0x8
05E7  0090     MOVWF SSP1CON1
27:                SDA_PPS_INPUT;
05E8  3014     MOVLW 0x14
05E9  017D     MOVLB 0x3D
05EA  00C6     MOVWF SSP1DATPPS
28:                SCK_PPS_INPUT;
05EB  3013     MOVLW 0x13
05EC  00C5     MOVWF SSP1CLKPPS
29:                SDA_PPS_OUTPUT;
05ED  3015     MOVLW 0x15
05EE  017E     MOVLB 0x3E
05EF  00A4     MOVWF RC4PPS
30:                SCK_PPS_OUTPUT;
05F0  3014     MOVLW 0x14
05F1  00A3     MOVWF RC3PPS
31:            }
05F2  0008     RETURN
32:            
33:            /* Name: I2C_Start
34:             * Parameter: void
35:             * Return: nothing
36:             * Description: Function issues a start condition. Start condition is the transition of SDA
37:             * from a high to low state while SCL is high */
38:            
39:            
40:            void I2C_Start(void){
41:            
42:                I2C_Idle_Check();
0578  3185     MOVLP 0x5
0579  25A6     CALL 0x5A6
057A  3185     MOVLP 0x5
43:                I2C_START_SEND;
057B  0143     MOVLB 0x3
057C  1411     BSF SSP1CON2, 0x0
44:                while(I2C_START_BIT == HIGH);
057D  1811     BTFSC SSP1CON2, 0x0
057E  2D80     GOTO 0x580
057F  2D81     GOTO 0x581
0580  2D7D     GOTO 0x57D
45:                //Flag_Polling();
46:            
47:            }
0581  0008     RETURN
48:            
49:            /* Name: I2C_Stop
50:             * Parameter: void
51:             * Return: nothing
52:             * Description: Function issues a stop condition. Stop condition is the transition of SDA
53:             * from a low to high state while SCL is high */
54:            
55:            void I2C_Stop(void){
56:            
57:                I2C_Idle_Check();
056C  3185     MOVLP 0x5
056D  25A6     CALL 0x5A6
056E  3185     MOVLP 0x5
58:                I2C_STOP_SEND;
056F  0143     MOVLB 0x3
0570  1511     BSF SSP1CON2, 0x2
59:                //Flag_Polling();
60:            
61:            
62:            }
0571  0008     RETURN
63:            /* Name: I2C_Restart
64:             * Parameter: void
65:             * Return: nothing
66:             * Description: Function issues a reset. Reset is valid any time a stop is valid. Master can
67:             *  issue reset which has same effect on the slave that a start would in resetting
68:             *  all slave logic. */
69:            
70:            void I2C_Restart(void){
71:            
72:                I2C_Idle_Check();
73:                I2C_RESEND;
74:            }
75:            
76:            
77:            /* Name: I2C_Write
78:             * Parameter: uint8_t
79:             * Return: nothing
80:             * Description: Function writes the data. Load slave address first to SSPxBUF. MMSP will shift
81:             *  notACK to ACKSTAT CON2 register. Then you can load 8 bits of data. notACK is
82:             * shifted again. */
83:            
84:            void I2C_Write(uint8_t I2C_data){
0582  00F0     MOVWF 0x1F0
85:            
86:                I2C_Idle_Check();
0583  3185     MOVLP 0x5
0584  25A6     CALL 0x5A6
0585  3185     MOVLP 0x5
87:                I2C_DATA_BUFFER = I2C_data;
0586  0870     MOVF 0x1F0, W
0587  0143     MOVLB 0x3
0588  008C     MOVWF SSP1BUF
88:                while(I2C_DATA_BIT == HIGH);
0589  180F     BTFSC SSP1STAT, 0x0
058A  2D8C     GOTO 0x58C
058B  2D8D     GOTO 0x58D
058C  2D89     GOTO 0x589
89:                //Flag_Polling();
90:            
91:            
92:                }
058D  0008     RETURN
93:            
94:            
95:            /* Name: I2C_NotAck_Read
96:             * Parameter: uint8_t
97:             * Return: nothing
98:             * Description: Function reads the data I2C. Load slave address to SSPxBUF. MMSP will shift
99:             *  notACK to ACKSTAT CON2 register. Set the RCEN bit of CON2. After 8th edge,
100:            * SSPxIF and BF are set.  Master sets ACK in ACKDT bit of CON2 and initiates the
101:            * ACK be setting ACKEN bit. */
102:           
103:           void I2C_NotAck_Read(uint8_t *rx_data){
104:           
105:           
106:               I2C_RECEIVE;
107:               while(I2C_DATA_BIT == LOW);
108:               //Flag_Polling();
109:               *rx_data = I2C_DATA_BUFFER;
110:               I2C_Idle_Check();
111:               I2C_ACK_SEQ;
112:               I2C_ACK = NOT_ACKNOWLEDGE;
113:              //Flag_Polling();
114:           
115:           }
116:           
117:           
118:           /* Name: I2C_Ack_Read
119:            * Parameter: uint8_t
120:            * Return: nothing
121:            * Description: Reads the data I2C and acknowledges. Load slave address to SSPxBUF. MMSP will shift
122:            * ACK to ACKSTAT CON2 register. Set the RCEN bit of CON2. After 8th edge,
123:            * SSPxIF and BF are set.  Master sets ACK in ACKDT bit of CON2 and initiates the
124:            * ACK be setting ACKEN bit. */
125:           
126:           void I2C_Ack_Read(uint8_t *rx_data, uint8_t count){
127:           
128:           
129:               I2C_RECEIVE;
130:               while(I2C_DATA_BIT == 0);
131:               //Flag_Polling();
132:               *rx_data = I2C_DATA_BUFFER;
133:               I2C_Idle_Check();
134:               I2C_ACK_SEQ;
135:               I2C_ACK = ACKNOWLEDGE;
136:               //Flag_Polling();
137:           
138:           
139:           }
140:           
141:           
142:           /***************************************************************************
143:             =========================== Private Functions ===========================
144:            ***************************************************************************/
145:           
146:           
147:           
148:           /* Name: I2C_Idle_Check
149:            * Parameter: void
150:            * Return: nothing
151:            * Description: Function checks to see if I2C is idle or transmitting*/
152:           
153:           static void I2C_Idle_Check(void){
154:           
155:               while(I2C_IDLE);
05A6  3004     MOVLW 0x4
05A7  0143     MOVLB 0x3
05A8  060F     XORWF SSP1STAT, W
05A9  1903     BTFSC STATUS, 0x2
05AA  2DAC     GOTO 0x5AC
05AB  2DAD     GOTO 0x5AD
05AC  2DA6     GOTO 0x5A6
05AD  301F     MOVLW 0x1F
05AE  0611     XORWF SSP1CON2, W
05AF  1903     BTFSC STATUS, 0x2
05B0  2DB2     GOTO 0x5B2
05B1  2DB3     GOTO 0x5B3
05B2  2DA6     GOTO 0x5A6
156:           
157:           }
05B3  0008     RETURN
158:           
159:           /* Name: SPxIF_flag_polling
160:            * Parameter: void
161:            * Return: nothing
162:            * Description: Clears the interrupt flag */
163:           
164:           
165:           static void Flag_Polling(void){
166:           
167:               while(!I2C_IF){
168:           
169:               }
170:               I2C_CLEAR_IF;
171:           }
---  /home/rcjk/Nextcloud/Programming/PIC16F18877/in_progress/SSD1306_drivers.c  ------------------------
1:             /***************************************************************************
2:              ================================ Includes =================================
3:              ***************************************************************************/
4:             
5:             
6:             #include <stdint.h>
7:             #include <stdint.h>
8:             #include <stdbool.h>
9:             #include "../libs/i2c_drivers.h"
10:            #include "SSD1306_drivers.h"
11:            
12:            
13:            
14:            /* Name: SSD1306_Command()
15:             * Parameter: uint_8t pointer, uint8_t
16:             * Return: Nothing
17:             * Description: Takes two parameters, one that point to memory location of array and second is just an int.
18:             *              Starts I2C and sets the Co and D/C# for write command mode to SSD1306.
19:             *              Writes addres to device, issues command mode then send the data by looping through the array.
20:             */
21:            
22:            void SSD1306_Command(const uint8_t *array, uint8_t size_array){
23:            
24:                I2C_Start();    // Start bit
061F  3185     MOVLP 0x5
0620  2578     CALL 0x578
0621  3186     MOVLP 0x6
25:                I2C_Write(I2C_ADDRESS); // Write address
0622  3078     MOVLW 0x78
0623  3185     MOVLP 0x5
0624  2582     CALL 0x582
0625  3186     MOVLP 0x6
26:                I2C_Write(COMMAND); // Write command mode
0626  3000     MOVLW 0x0
0627  3185     MOVLP 0x5
0628  2582     CALL 0x582
0629  3186     MOVLP 0x6
27:            
28:                for(int i = 0; i < size_array; i++){
062A  01F5     CLRF 0x1F5
062B  01F6     CLRF 0x1F6
062C  2E3B     GOTO 0x63B
29:                  I2C_Write(array[i]);
062D  0871     MOVF 0x1F1, W
062E  0775     ADDWF 0x1F5, W
062F  0084     MOVWF FSR0L
0630  0872     MOVF 0x1F2, W
0631  3D76     ADDWFC 0x1F6, W
0632  0085     MOVWF FSR0H
0633  0800     MOVF INDF0, W
0634  3185     MOVLP 0x5
0635  2582     CALL 0x582
0636  3186     MOVLP 0x6
30:            
31:                }
0637  3001     MOVLW 0x1
0638  07F5     ADDWF 0x1F5, F
0639  3000     MOVLW 0x0
063A  3DF6     ADDWFC 0x1F6, F
063B  0876     MOVF 0x1F6, W
063C  3A80     XORLW 0x80
063D  00F4     MOVWF 0x1F4
063E  3080     MOVLW 0x80
063F  0274     SUBWF 0x1F4, W
0640  1D03     BTFSS STATUS, 0x2
0641  2E44     GOTO 0x644
0642  0873     MOVF 0x1F3, W
0643  0275     SUBWF 0x1F5, W
0644  1C03     BTFSS STATUS, 0x0
0645  2E47     GOTO 0x647
0646  2E48     GOTO 0x648
0647  2E2D     GOTO 0x62D
32:                I2C_Stop();
0648  3185     MOVLP 0x5
0649  256C     CALL 0x56C
064A  3186     MOVLP 0x6
33:            
34:            }
064B  0008     RETURN
35:            
36:            
37:            /* Name: SSD1306_Data())
38:             * Parameter: void
39:             * Return: Nothing
40:             * Description: Sets the Co and D/C# for write data mode to SSD1306.
41:             *              Then start I2C, writes addres to device and after stops I2C communication.
42:             */
43:            
44:            void SSD1306_Data(){
45:            
46:                I2C_Start();    // Start bit
059A  3185     MOVLP 0x5
059B  2578     CALL 0x578
059C  3185     MOVLP 0x5
47:                I2C_Write(I2C_ADDRESS); // Write address
059D  3078     MOVLW 0x78
059E  3185     MOVLP 0x5
059F  2582     CALL 0x582
05A0  3185     MOVLP 0x5
48:                I2C_Write(DATA); // Write command mode
05A1  3040     MOVLW 0x40
05A2  3185     MOVLP 0x5
05A3  2582     CALL 0x582
05A4  3185     MOVLP 0x5
49:            
50:            }
05A5  0008     RETURN
51:            /* Name: SSD1306_Init()
52:             * Parameter: void
53:             * Return: nothing
54:             * Description: This is the initalization sequence for the SSD1306. Will exectue all the following
55:             *              to get OLED into a ready state.
56:             */
57:            
58:            void SSD1306_Init(void){
59:            
60:              SSD1306_Command(horz_init, sizeof(horz_init));
058E  30DB     MOVLW 0xDB
058F  00F1     MOVWF 0x1F1
0590  3089     MOVLW 0x89
0591  00F2     MOVWF 0x1F2
0592  3017     MOVLW 0x17
0593  00F7     MOVWF 0x1F7
0594  0877     MOVF 0x1F7, W
0595  00F3     MOVWF 0x1F3
0596  3186     MOVLP 0x6
0597  261F     CALL 0x61F
0598  3185     MOVLP 0x5
61:            }
0599  0008     RETURN
62:            
63:            
64:            /* Name: horizontal_clear_screen
65:             * Parameter: uint8_t
66:             * Return: nothing
67:             * Description: Function to clear entire screen. Issues the commands followed by a for loop to
68:             *              clear or wirte each pixel. 128 rows and 4 columns (8 bits tall each)
69:             */
70:            
71:            void horizontal_fill_screen(uint8_t value){
064C  00F8     MOVWF 0x1F8
72:            
73:              SSD1306_Command(entire_screen, sizeof(entire_screen));
064D  30F2     MOVLW 0xF2
064E  00F1     MOVWF 0x1F1
064F  3089     MOVLW 0x89
0650  00F2     MOVWF 0x1F2
0651  3006     MOVLW 0x6
0652  00F7     MOVWF 0x1F7
0653  0877     MOVF 0x1F7, W
0654  00F3     MOVWF 0x1F3
0655  3186     MOVLP 0x6
0656  261F     CALL 0x61F
0657  3186     MOVLP 0x6
74:            
75:              SSD1306_Data();
0658  3185     MOVLP 0x5
0659  259A     CALL 0x59A
065A  3186     MOVLP 0x6
76:            
77:              for( uint8_t i = 0, j = 0; j < 5; j++ ){
065B  01FA     CLRF 0x1FA
065C  01F9     CLRF 0x1F9
065D  2E5E     GOTO 0x65E
78:                for(; i < 127; i++){
79:                    I2C_Write(value);
065E  0878     MOVF 0x1F8, W
065F  3185     MOVLP 0x5
0660  2582     CALL 0x582
0661  3186     MOVLP 0x6
80:                }
0662  3001     MOVLW 0x1
0663  00F7     MOVWF 0x1F7
0664  0877     MOVF 0x1F7, W
0665  07FA     ADDWF 0x1FA, F
0666  307F     MOVLW 0x7F
0667  027A     SUBWF 0x1FA, W
0668  1C03     BTFSS STATUS, 0x0
0669  2E6B     GOTO 0x66B
066A  2E6C     GOTO 0x66C
066B  2E5E     GOTO 0x65E
81:                i = 0;
066C  01FA     CLRF 0x1FA
82:              }
066D  3001     MOVLW 0x1
066E  00F7     MOVWF 0x1F7
066F  0877     MOVF 0x1F7, W
0670  07F9     ADDWF 0x1F9, F
0671  3005     MOVLW 0x5
0672  0279     SUBWF 0x1F9, W
0673  1C03     BTFSS STATUS, 0x0
0674  2E76     GOTO 0x676
0675  2E77     GOTO 0x677
0676  2E5E     GOTO 0x65E
83:            
84:             I2C_Stop();
0677  3185     MOVLP 0x5
0678  256C     CALL 0x56C
0679  3186     MOVLP 0x6
85:            
86:            }
067A  0008     RETURN
87:            
88:            /* Name: GotoXY()
89:             * Parameter: uint8_t, uint8_t
90:             * Return: nothing
91:             * Description: function takes start/end columns and start end rows. Array is created and values are writen to array which is then
92:             *              def into the SSD1306_Command function.
93:             *
94:             * */
95:            
96:            
97:            void Horz_Goto_XY(uint8_t start_column, uint8_t end_column, uint8_t start_row, uint8_t end_row) {
05F3  0140     MOVLB 0x0
05F4  00A6     MOVWF start_column
98:            
99:              uint8_t goto_xy[6] = {
05F5  3045     MOVLW 0x45
05F6  0086     MOVWF FSR1
05F7  3000     MOVLW 0x0
05F8  0087     MOVWF FSR1H
05F9  3020     MOVLW 0x20
05FA  0084     MOVWF FSR0
05FB  3000     MOVLW 0x0
05FC  0085     MOVWF FSR0H
05FD  3006     MOVLW 0x6
05FE  00FA     MOVWF i
05FF  0016     MOVIW FSR1++
0600  001A     MOVWI FSR0++
0601  0BFA     DECFSZ i, F
0602  2DFF     GOTO 0x5FF
100:           
101:             COLUMNADDR,
102:             0x00,
103:             0x00,
104:             PAGEADDR,
105:             0x00,
106:             0x03,
107:           };
108:           
109:             goto_xy[1] = start_column;
0603  0826     MOVF start_column, W
0604  00FA     MOVWF i
0605  087A     MOVF i, W
0606  00A1     MOVWF 0x21
110:             goto_xy[2] = end_column;
0607  0877     MOVF end_column, W
0608  00FA     MOVWF i
0609  087A     MOVF i, W
060A  00A2     MOVWF 0x22
111:             goto_xy[4] = start_row;
060B  0878     MOVF value, W
060C  00FA     MOVWF i
060D  087A     MOVF i, W
060E  00A4     MOVWF 0x24
112:             goto_xy[5] = end_row;
060F  0879     MOVF j, W
0610  00FA     MOVWF i
0611  087A     MOVF i, W
0612  00A5     MOVWF 0x25
113:           
114:             SSD1306_Command(goto_xy, 6);
0613  3020     MOVLW 0x20
0614  00F1     MOVWF array
0615  3000     MOVLW 0x0
0616  00F2     MOVWF product
0617  3006     MOVLW 0x6
0618  00FA     MOVWF i
0619  087A     MOVF i, W
061A  00F3     MOVWF size_array
061B  3186     MOVLP 0x6
061C  261F     CALL 0x61F
061D  3185     MOVLP 0x5
115:           
116:           }
061E  0008     RETURN
117:           
118:           
119:           void draw_test(){
120:           /*  I2C_Write(I2C_ADDRESS);
121:             I2C_Write(0x00);
122:             I2C_Write(COLUMNADDR);
123:             I2C_Write(0x0A);
124:             I2C_Write(0x7F);
125:             I2C_Write(PAGEADDR);
126:             I2C_Write(0x02);
127:             I2C_Write(0x01);
128:             I2C_Stop();
129:           */
130:             I2C_Start();
131:             I2C_Write(I2C_ADDRESS);
132:             I2C_Write(0x40);
133:           
134:             I2C_Write(0x7F);
135:             I2C_Write(0x08);
136:             I2C_Write(0x08);
137:             I2C_Write(0x08);
138:             I2C_Write(0x7F);
139:             
140:             I2C_Write(0x00);
141:             I2C_Write(0x00);
142:             I2C_Write(0x00);
143:             I2C_Write(0x00);
144:             I2C_Write(0x00);
145:             
146:             I2C_Write(0x7F);
147:             I2C_Write(0x49);
148:             I2C_Write(0x49);
149:             I2C_Write(0x49);
150:             I2C_Write(0x41);
151:           
152:             I2C_Write(0x00);
153:             I2C_Write(0x00);
154:             I2C_Write(0x00);
155:             I2C_Write(0x00);
156:             I2C_Write(0x00);
157:             
158:             I2C_Write(0x7F);
159:             I2C_Write(0x40);
160:             I2C_Write(0x40);
161:             I2C_Write(0x40);
162:             I2C_Write(0x40);
163:           
164:             I2C_Write(0x00);
165:             I2C_Write(0x00);
166:             I2C_Write(0x00);
167:             I2C_Write(0x00);
168:             I2C_Write(0x00);
169:           
170:             I2C_Write(0x7F);
171:             I2C_Write(0x40);
172:             I2C_Write(0x40);
173:             I2C_Write(0x40);
174:             I2C_Write(0x40);
175:           
176:             I2C_Write(0x00);
177:             I2C_Write(0x00);
178:             I2C_Write(0x00);
179:             I2C_Write(0x00);
180:             I2C_Write(0x00);
181:               
182:             I2C_Write(0x3E);
183:             I2C_Write(0x41);
184:             I2C_Write(0x41);
185:             I2C_Write(0x41);
186:             I2C_Write(0x3E);
187:           
188:             
189:           
190:            
191:           
192:             I2C_Stop();
193:           
194:           }
195:           
196:           uint8_t GotoXY(uint8_t row, uint8_t column){
197:           
198:           
199:           // ============================ Page Addressing =========================== //
200:           // Example from data sheet: Want to write PAGE2 Column 3
201:           // Write 0xB2 (PAGE2)
202:           // Write lower start aka lower nibble 0x03
203:           // Write upper start aka upper nibble 0x10
204:           // In binary it looks like this 1 0000 0011
205:           // Basically for the upper start, the upper nibble is ignored
206:           // My own example Column 96
207:           // Lower nibble = 0x06
208:           // Upper nibble = 0x19
209:           // Binary looks like 1 1001 0110
210:           // ====================================================================== //
211:           //
212:             uint8_t byte;
213:             uint8_t lower_nibble =(column & 0x0F);  // Takes column AND with 0x0F to only get lower nibble
214:             uint8_t upper_nibble = (column & 0xF0); // Takes colum AND with 0xF0 to only get upper nibble
215:             uint8_t upper_final = ((upper_nibble >>= 4) + 0x10); // Bitshift right 4 to only have upper nibble then add 0x10
216:             byte = upper_nibble + lower_nibble;
217:             x_pos = &byte;
218:             y_pos = &row;
219:           
220:             I2C_Write(0xB0 + row); // Start PAGE Address
221:             I2C_Write(0x00 + lower_nibble); //Start lower nibble address
222:             I2C_Write(0x00 + upper_final); //Start upper nibble address
223:             I2C_Stop();
224:           
225:           }
226:           /* Name: put_char
227:            * Parameter: char pointer
228:            * Return: Nothing
229:            * Description: function that will draw a character from the font array. Passes one character
230:            *              which will subtract value 32 to start at array times 5 since there are 5
231:            *             values per characer. Calls SSD1306_data funct to write */
232:           
233:           void put_char(char *font){
234:              uint8_t i = ((*font) - 32);
067B  0874     MOVF font, W
067C  0086     MOVWF FSR1
067D  0875     MOVF i, W
067E  0087     MOVWF FSR1H
067F  0801     MOVF INDF1, W
0680  3EE0     ADDLW 0xE0
0681  00F6     MOVWF 0x76
0682  0876     MOVF 0x76, W
0683  00F9     MOVWF j
235:              i = ( i * 5);
0684  3005     MOVLW 0x5
0685  00F6     MOVWF 0x76
0686  0876     MOVF 0x76, W
0687  00F0     MOVWF __pcstackCOMMON
0688  0879     MOVF j, W
0689  3185     MOVLP 0x5
068A  25C6     CALL 0x5C6
068B  3186     MOVLP 0x6
068C  00F7     MOVWF end_column
068D  0877     MOVF end_column, W
068E  00F9     MOVWF j
236:              uint8_t limit = (i + 5);
068F  0879     MOVF j, W
0690  3E05     ADDLW 0x5
0691  00F6     MOVWF 0x76
0692  0876     MOVF 0x76, W
0693  00F8     MOVWF value
237:              for( ; i < limit; i++){
0694  2EA4     GOTO 0x6A4
238:               I2C_Write(Font[i]);
0695  0879     MOVF j, W
0696  3E00     ADDLW 0x0
0697  0084     MOVWF FSR0
0698  3088     MOVLW 0x88
0699  1803     BTFSC STATUS, 0x0
069A  3E01     ADDLW 0x1
069B  0085     MOVWF FSR0H
069C  0800     MOVF INDF0, W
069D  3185     MOVLP 0x5
069E  2582     CALL 0x582
069F  3186     MOVLP 0x6
239:                }
06A0  3001     MOVLW 0x1
06A1  00F6     MOVWF 0x76
06A2  0876     MOVF 0x76, W
06A3  07F9     ADDWF j, F
06A4  0878     MOVF value, W
06A5  0279     SUBWF j, W
06A6  1C03     BTFSS STATUS, 0x0
06A7  2EA9     GOTO 0x6A9
06A8  2EAA     GOTO 0x6AA
06A9  2E95     GOTO 0x695
240:              I2C_Stop();
06AA  3185     MOVLP 0x5
06AB  256C     CALL 0x56C
06AC  3186     MOVLP 0x6
241:           
242:           }
06AD  0008     RETURN
---  /home/rcjk/Nextcloud/Programming/OLED.X/main.c  ----------------------------------------------------
1:             /*
2:              * File:   main.c
3:              * Author: ryan
4:              *
5:              * Created on July 23, 2022, 8:34 PM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "../PIC16F18877/libs/i2c_drivers.h"
11:            #include "../PIC16F18877/in_progress/SSD1306_drivers.h"
12:            #include "mcc_generated_files/mcc.h"
13:                
14:            // CONFIG1
15:            #pragma config FEXTOSC = OFF    // External Oscillator mode selection bits->Oscillator not enabled
16:            #pragma config RSTOSC = HFINT1    // Power-up default value for COSC bits->HFINTOSC (1MHz)
17:            #pragma config CLKOUTEN = OFF    // Clock Out Enable bit->CLKOUT function is disabled; i/o or oscillator function on OSC2
18:            #pragma config CSWEN = ON    // Clock Switch Enable bit->Writing to NOSC and NDIV is allowed
19:            #pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable bit->FSCM timer enabled
20:            
21:            // CONFIG2
22:            #pragma config MCLRE = ON    // Master Clear Enable bit->MCLR pin is Master Clear function
23:            #pragma config PWRTE = OFF    // Power-up Timer Enable bit->PWRT disabled
24:            #pragma config LPBOREN = OFF    // Low-Power BOR enable bit->ULPBOR disabled
25:            #pragma config BOREN = ON    // Brown-out reset enable bits->Brown-out Reset Enabled, SBOREN bit is ignored
26:            #pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (VBOR) set to 1.9V on LF, and 2.45V on F Devices
27:            #pragma config ZCD = OFF    // Zero-cross detect disable->Zero-cross detect circuit is disabled at POR.
28:            #pragma config PPS1WAY = ON    // Peripheral Pin Select one-way control->The PPSLOCK bit can be cleared and set only once in software
29:            #pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable bit->Stack Overflow or Underflow will cause a reset
30:            #pragma config DEBUG = OFF    // Background Debugger->Background Debugger disabled
31:            
32:            // CONFIG3
33:            #pragma config WDTCPS = WDTCPS_31    // WDT Period Select bits->Divider ratio 1:65536; software control of WDTPS
34:            #pragma config WDTE = OFF    // WDT operating mode->WDT Disabled, SWDTEN is ignored
35:            #pragma config WDTCWS = WDTCWS_7    // WDT Window Select bits->window always open (100%); software control; keyed access not required
36:            #pragma config WDTCCS = SC    // WDT input clock selector->Software Control
37:            
38:            // CONFIG4
39:            #pragma config WRT = OFF    // UserNVM self-write protection bits->Write protection off
40:            #pragma config SCANE = available    // Scanner Enable bit->Scanner module is available for use
41:            #pragma config LVP = ON    // Low Voltage Programming Enable bit->Low Voltage programming enabled. MCLR/Vpp pin function is MCLR.
42:            
43:            // CONFIG5
44:            #pragma config CP = OFF    // UserNVM Program memory code protection bit->Program Memory code protection disabled
45:            #pragma config CPD = OFF    // DataNVM code protection bit->Data EEPROM code protection disabled
46:            
47:            
48:            void main(void) {
49:                
50:                char phrase[] ={
06AE  303A     MOVLW 0x3A
06AF  0086     MOVWF FSR1
06B0  3000     MOVLW 0x0
06B1  0087     MOVWF FSR1H
06B2  3027     MOVLW 0x27
06B3  0084     MOVWF FSR0
06B4  3000     MOVLW 0x0
06B5  0085     MOVWF FSR0H
06B6  300B     MOVLW 0xB
06B7  00FB     MOVWF 0x7B
06B8  0016     MOVIW FSR1++
06B9  001A     MOVWI FSR0++
06BA  0BFB     DECFSZ 0x7B, F
06BB  2EB8     GOTO 0x6B8
51:                    'H','A','V','E','N',' ','L','A','B','S','!'
52:                };
53:                    // NOSC HFINTOSC; NDIV 1; 
54:                OSCCON1 = 0x60;
06BC  3060     MOVLW 0x60
06BD  0151     MOVLB 0x11
06BE  008D     MOVWF OSCCON1
55:                // CSWHOLD may proceed; SOSCPWR Low power; 
56:                OSCCON3 = 0x00;
06BF  018F     CLRF OSCCON3
57:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
58:                OSCEN = 0x00;
06C0  0191     CLRF OSCEN
59:                // HFFRQ 16_MHz; 
60:                OSCFRQ = 0x05;
06C1  3005     MOVLW 0x5
06C2  0093     MOVWF OSCFRQ
61:                // HFTUN 0; 
62:                OSCTUNE = 0x00;
06C3  0192     CLRF OSCTUNE
63:                
64:                I2C_Init();
06C4  3185     MOVLP 0x5
06C5  25DB     CALL 0x5DB
06C6  3186     MOVLP 0x6
65:                //SSD1306_Command(DISPLAYOFF);
66:                SSD1306_Init();
06C7  3185     MOVLP 0x5
06C8  258E     CALL 0x58E
06C9  3186     MOVLP 0x6
67:                //init_test();
68:                //GotoXY(1,50);
69:                //I2C_Stop();
70:                //Draw_pixel();
71:                //I2C_Stop();
72:                //SSD1306_Command(DISPLAYALLON_RESUME);
73:                
74:                while(1){
75:                horizontal_fill_screen(0x55);
06CA  3055     MOVLW 0x55
06CB  3186     MOVLP 0x6
06CC  264C     CALL 0x64C
06CD  3186     MOVLP 0x6
76:                __delay_ms(1000);
06CE  3015     MOVLW 0x15
06CF  00FC     MOVWF 0x8FC
06D0  304B     MOVLW 0x4B
06D1  00FB     MOVWF 0x8FB
06D2  30BE     MOVLW 0xBE
06D3  0B89     DECFSZ WREG, F
06D4  2ED3     GOTO 0x6D3
06D5  0BFB     DECFSZ 0x8FB, F
06D6  2ED3     GOTO 0x6D3
06D7  0BFC     DECFSZ 0x8FC, F
06D8  2ED3     GOTO 0x6D3
06D9  3200     BRA 0x6DA
77:                horizontal_fill_screen(0x00);
06DA  3000     MOVLW 0x0
06DB  3186     MOVLP 0x6
06DC  264C     CALL 0x64C
06DD  3186     MOVLP 0x6
78:                Horz_Goto_XY(0x34,0x79,0x00,0x01);
06DE  3079     MOVLW 0x79
06DF  00FB     MOVWF 0x8FB
06E0  087B     MOVF 0x8FB, W
06E1  00F7     MOVWF 0x8F7
06E2  01F8     CLRF 0x8F8
06E3  01F9     CLRF 0x8F9
06E4  0AF9     INCF 0x8F9, F
06E5  3034     MOVLW 0x34
06E6  3185     MOVLP 0x5
06E7  25F3     CALL 0x5F3
06E8  3186     MOVLP 0x6
79:                SSD1306_Data();
06E9  3185     MOVLP 0x5
06EA  259A     CALL 0x59A
06EB  3186     MOVLP 0x6
80:                
81:                for(int i = 0; i < 11; i++)
06EC  0140     MOVLB 0x0
06ED  01B2     CLRF i
06EE  01B3     CLRF 0x33
82:                put_char(phrase[i]);
06EF  0140     MOVLB 0x0
06F0  0832     MOVF i, W
06F1  3E27     ADDLW 0x27
06F2  0086     MOVWF FSR1
06F3  0187     CLRF FSR1H
06F4  0801     MOVF INDF1, W
06F5  00FB     MOVWF 0x7B
06F6  01FC     CLRF 0x7C
06F7  087B     MOVF 0x7B, W
06F8  00F4     MOVWF font
06F9  087C     MOVF 0x7C, W
06FA  00F5     MOVWF i
06FB  3186     MOVLP 0x6
06FC  267B     CALL 0x67B
06FD  3186     MOVLP 0x6
06FE  3001     MOVLW 0x1
06FF  0140     MOVLB 0x0
0700  07B2     ADDWF i, F
0701  3000     MOVLW 0x0
0702  3DB3     ADDWFC 0x33, F
0703  0833     MOVF 0x33, W
0704  3A80     XORLW 0x80
0705  00FB     MOVWF 0x7B
0706  3080     MOVLW 0x80
0707  027B     SUBWF 0x7B, W
0708  1D03     BTFSS STATUS, 0x2
0709  2F0C     GOTO 0x70C
070A  300B     MOVLW 0xB
070B  0232     SUBWF i, W
070C  1C03     BTFSS STATUS, 0x0
070D  2F0F     GOTO 0x70F
070E  2F10     GOTO 0x710
070F  2EEF     GOTO 0x6EF
83:               
84:                __delay_ms(2000);
0710  3029     MOVLW 0x29
0711  00FC     MOVWF 0x7C
0712  3096     MOVLW 0x96
0713  00FB     MOVWF 0x7B
0714  307F     MOVLW 0x7F
0715  0B89     DECFSZ WREG, F
0716  2F15     GOTO 0x715
0717  0BFB     DECFSZ 0x7B, F
0718  2F15     GOTO 0x715
0719  0BFC     DECFSZ 0x7C, F
071A  2F15     GOTO 0x715
071B  0000     NOP
85:                horizontal_fill_screen(0x00);
071C  3000     MOVLW 0x0
071D  3186     MOVLP 0x6
071E  264C     CALL 0x64C
071F  3186     MOVLP 0x6
86:                Horz_Goto_XY(0x01,0x46,0x02,0x03);
0720  3046     MOVLW 0x46
0721  00FB     MOVWF 0x7B
0722  087B     MOVF 0x7B, W
0723  00F7     MOVWF end_column
0724  3002     MOVLW 0x2
0725  00FC     MOVWF 0x7C
0726  087C     MOVF 0x7C, W
0727  00F8     MOVWF value
0728  3003     MOVLW 0x3
0729  00FD     MOVWF 0x7D
072A  087D     MOVF 0x7D, W
072B  00F9     MOVWF j
072C  3001     MOVLW 0x1
072D  3185     MOVLP 0x5
072E  25F3     CALL 0x5F3
072F  3186     MOVLP 0x6
87:                SSD1306_Data();
0730  3185     MOVLP 0x5
0731  259A     CALL 0x59A
0732  3186     MOVLP 0x6
88:                
89:                for(int i = 0; i < 11; i++)
0733  0140     MOVLB 0x0
0734  01B4     CLRF i
0735  01B5     CLRF 0x35
90:                put_char(phrase[i]);
0736  0140     MOVLB 0x0
0737  0834     MOVF i, W
0738  3E27     ADDLW 0x27
0739  0086     MOVWF FSR1
073A  0187     CLRF FSR1H
073B  0801     MOVF INDF1, W
073C  00FB     MOVWF 0x7B
073D  01FC     CLRF 0x7C
073E  087B     MOVF 0x7B, W
073F  00F4     MOVWF font
0740  087C     MOVF 0x7C, W
0741  00F5     MOVWF i
0742  3186     MOVLP 0x6
0743  267B     CALL 0x67B
0744  3186     MOVLP 0x6
0745  3001     MOVLW 0x1
0746  0140     MOVLB 0x0
0747  07B4     ADDWF i, F
0748  3000     MOVLW 0x0
0749  3DB5     ADDWFC 0x35, F
074A  0835     MOVF 0x35, W
074B  3A80     XORLW 0x80
074C  00FB     MOVWF 0x7B
074D  3080     MOVLW 0x80
074E  027B     SUBWF 0x7B, W
074F  1D03     BTFSS STATUS, 0x2
0750  2F53     GOTO 0x753
0751  300B     MOVLW 0xB
0752  0234     SUBWF i, W
0753  1C03     BTFSS STATUS, 0x0
0754  2F56     GOTO 0x756
0755  2F57     GOTO 0x757
0756  2F36     GOTO 0x736
91:               
92:                __delay_ms(2000);
0757  3029     MOVLW 0x29
0758  00FC     MOVWF 0x7C
0759  3096     MOVLW 0x96
075A  00FB     MOVWF 0x7B
075B  307F     MOVLW 0x7F
075C  0B89     DECFSZ WREG, F
075D  2F5C     GOTO 0x75C
075E  0BFB     DECFSZ 0x7B, F
075F  2F5C     GOTO 0x75C
0760  0BFC     DECFSZ 0x7C, F
0761  2F5C     GOTO 0x75C
0762  0000     NOP
93:                horizontal_fill_screen(0x00);
0763  3000     MOVLW 0x0
0764  3186     MOVLP 0x6
0765  264C     CALL 0x64C
0766  3186     MOVLP 0x6
94:                Horz_Goto_XY(0x50,0x7D,0x01,0x02);
0767  307D     MOVLW 0x7D
0768  00FB     MOVWF 0x7B
0769  087B     MOVF 0x7B, W
076A  00F7     MOVWF end_column
076B  01F8     CLRF value
076C  0AF8     INCF value, F
076D  3002     MOVLW 0x2
076E  00FC     MOVWF 0x7C
076F  087C     MOVF 0x7C, W
0770  00F9     MOVWF j
0771  3050     MOVLW 0x50
0772  3185     MOVLP 0x5
0773  25F3     CALL 0x5F3
0774  3186     MOVLP 0x6
95:                SSD1306_Data();
0775  3185     MOVLP 0x5
0776  259A     CALL 0x59A
0777  3186     MOVLP 0x6
96:                
97:                for(int i = 0; i < 11; i++)
0778  0140     MOVLB 0x0
0779  01B6     CLRF i
077A  01B7     CLRF 0x37
98:                put_char(&phrase[i]);
077B  0140     MOVLB 0x0
077C  0836     MOVF i, W
077D  3E27     ADDLW 0x27
077E  00F4     MOVWF font
077F  3000     MOVLW 0x0
0780  00F5     MOVWF i
0781  3186     MOVLP 0x6
0782  267B     CALL 0x67B
0783  3186     MOVLP 0x6
0784  3001     MOVLW 0x1
0785  0140     MOVLB 0x0
0786  07B6     ADDWF i, F
0787  3000     MOVLW 0x0
0788  3DB7     ADDWFC 0x37, F
0789  0837     MOVF 0x37, W
078A  3A80     XORLW 0x80
078B  00FB     MOVWF 0x7B
078C  3080     MOVLW 0x80
078D  027B     SUBWF 0x7B, W
078E  1D03     BTFSS STATUS, 0x2
078F  2F92     GOTO 0x792
0790  300B     MOVLW 0xB
0791  0236     SUBWF i, W
0792  1C03     BTFSS STATUS, 0x0
0793  2F95     GOTO 0x795
0794  2F96     GOTO 0x796
0795  2F7B     GOTO 0x77B
99:               
100:               __delay_ms(2000);
0796  3029     MOVLW 0x29
0797  00FC     MOVWF 0x7C
0798  3096     MOVLW 0x96
0799  00FB     MOVWF 0x7B
079A  307F     MOVLW 0x7F
079B  0B89     DECFSZ WREG, F
079C  2F9B     GOTO 0x79B
079D  0BFB     DECFSZ 0x7B, F
079E  2F9B     GOTO 0x79B
079F  0BFC     DECFSZ 0x7C, F
07A0  2F9B     GOTO 0x79B
07A1  0000     NOP
101:               horizontal_fill_screen(0x00);
07A2  3000     MOVLW 0x0
07A3  3186     MOVLP 0x6
07A4  264C     CALL 0x64C
07A5  3186     MOVLP 0x6
102:               Horz_Goto_XY(0x2D,0x5A,0x03,0x03);
07A6  305A     MOVLW 0x5A
07A7  00FB     MOVWF 0x7B
07A8  087B     MOVF 0x7B, W
07A9  00F7     MOVWF end_column
07AA  3003     MOVLW 0x3
07AB  00FC     MOVWF 0x7C
07AC  087C     MOVF 0x7C, W
07AD  00F8     MOVWF value
07AE  3003     MOVLW 0x3
07AF  00FD     MOVWF 0x7D
07B0  087D     MOVF 0x7D, W
07B1  00F9     MOVWF j
07B2  302D     MOVLW 0x2D
07B3  3185     MOVLP 0x5
07B4  25F3     CALL 0x5F3
07B5  3186     MOVLP 0x6
103:               SSD1306_Data();
07B6  3185     MOVLP 0x5
07B7  259A     CALL 0x59A
07B8  3186     MOVLP 0x6
104:              
105:               for(int i = 0; i < 11; i++)
07B9  0140     MOVLB 0x0
07BA  01B8     CLRF i
07BB  01B9     CLRF 0x39
106:               put_char(&phrase[i]);
07BC  0140     MOVLB 0x0
07BD  0838     MOVF i, W
07BE  3E27     ADDLW 0x27
07BF  00F4     MOVWF font
07C0  3000     MOVLW 0x0
07C1  00F5     MOVWF i
07C2  3186     MOVLP 0x6
07C3  267B     CALL 0x67B
07C4  3186     MOVLP 0x6
07C5  3001     MOVLW 0x1
07C6  0140     MOVLB 0x0
07C7  07B8     ADDWF i, F
07C8  3000     MOVLW 0x0
07C9  3DB9     ADDWFC 0x39, F
07CA  0839     MOVF 0x39, W
07CB  3A80     XORLW 0x80
07CC  00FB     MOVWF 0x7B
07CD  3080     MOVLW 0x80
07CE  027B     SUBWF 0x7B, W
07CF  1D03     BTFSS STATUS, 0x2
07D0  2FD3     GOTO 0x7D3
07D1  300B     MOVLW 0xB
07D2  0238     SUBWF i, W
07D3  1C03     BTFSS STATUS, 0x0
07D4  2FD6     GOTO 0x7D6
07D5  2FD7     GOTO 0x7D7
07D6  2FBC     GOTO 0x7BC
107:              
108:               __delay_ms(2000);
07D7  3029     MOVLW 0x29
07D8  00FC     MOVWF 0x7C
07D9  3096     MOVLW 0x96
07DA  00FB     MOVWF 0x7B
07DB  307F     MOVLW 0x7F
07DC  0B89     DECFSZ WREG, F
07DD  2FDC     GOTO 0x7DC
07DE  0BFB     DECFSZ 0x7B, F
07DF  2FDC     GOTO 0x7DC
07E0  0BFC     DECFSZ 0x7C, F
07E1  2FDC     GOTO 0x7DC
07E2  0000     NOP
109:               horizontal_fill_screen(0x55);
07E3  3055     MOVLW 0x55
07E4  3186     MOVLP 0x6
07E5  264C     CALL 0x64C
07E6  3186     MOVLP 0x6
07E7  2ECA     GOTO 0x6CA
07E8  3180     MOVLP 0x0
110:               }
111:               
112:               
113:           }
